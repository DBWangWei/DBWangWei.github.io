<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DSAA2043 Spring 2025 Practice Questions</title>
    <!-- MathJax Configuration -->
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$']],
                displayMath: [['\\[','\\]']],
                processEscapes: true
            }
        });
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML"></script>
    <style>
        :root {
            --primary-color: #3498db;
            --secondary-color: #2c3e50;
            --accent-color: #e74c3c;
            --light-bg: #f7f9fb;
            --dark-bg: #34495e;
            --text-color: #333;
            --light-text: #fff;
            --border-radius: 6px;
            --box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            margin: 0;
            padding: 0;
            background-color: var(--light-bg);
        }
        
        .container {
            width: 100%;
            max-width: 100%;
            margin: 0 auto;
            padding: 20px;
            box-sizing: border-box;
        }
        
        header {
            background-color: var(--dark-bg);
            color: var(--light-text);
            padding: 1.5rem;
            text-align: center;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            box-shadow: var(--box-shadow);
        }
        
        h1 {
            margin: 0;
            font-size: 2.5rem;
        }
        
        .toc {
            background-color: white;
            padding: 1.5rem;
            border-radius: var(--border-radius);
            margin-bottom: 2rem;
            box-shadow: var(--box-shadow);
        }
        
        .toc h2 {
            color: var(--secondary-color);
            margin-top: 0;
            border-bottom: 2px solid var(--primary-color);
            padding-bottom: 10px;
        }
        
        .toc ul {
            list-style-type: none;
            padding: 0;
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 10px;
        }
        
        .toc li {
            margin: 10px 0;
            position: relative;
        }
        
        .toc a {
            display: block;
            padding: 10px 15px;
            background-color: var(--light-bg);
            color: var(--secondary-color);
            text-decoration: none;
            border-radius: var(--border-radius);
            transition: all 0.3s ease;
            border-left: 4px solid var(--primary-color);
        }
        
        .toc a:hover {
            background-color: var(--primary-color);
            color: white;
            transform: translateX(5px);
        }
        
        .question-card {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 2rem;
            margin-bottom: 2rem;
            box-shadow: var(--box-shadow);
            border-top: 5px solid var(--primary-color);
            position: relative;
        }
        
        .question-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .question-header h2 {
            color: var(--secondary-color);
            margin: 0;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--primary-color);
            flex-grow: 1;
        }
        
        .back-to-toc {
            display: inline-block;
            background-color: var(--secondary-color);
            color: white;
            font-size: 0.9rem;
            padding: 6px 12px;
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.3s;
            margin-left: 15px;
        }
        
        .back-to-toc:hover {
            background-color: var(--primary-color);
        }
        
        .question-content {
            margin-bottom: 20px;
        }
        
        .solution-container {
            border-top: 1px dashed #ccc;
            padding-top: 15px;
        }
        
        .solution-content {
            display: none;
            background-color: #f1f8e9;
            padding: 15px;
            border-radius: var(--border-radius);
            border-left: 4px solid #8bc34a;
        }
        
        .show-solution-btn {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
        }
        
        .show-solution-btn:hover {
            background-color: #2980b9;
        }
        
        pre {
            background-color: #282c34;
            color: #abb2bf;
            border-radius: var(--border-radius);
            padding: 15px;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
            line-height: 1.5;
        }
        
        code {
            font-family: 'Courier New', Courier, monospace;
            background-color: #f1f1f1;
            padding: 2px 5px;
            border-radius: 3px;
        }
        
        pre code {
            background-color: transparent;
            padding: 0;
        }
        
        .scrollToTop {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background-color: var(--primary-color);
            color: white;
            width: 50px;
            height: 50px;
            text-align: center;
            line-height: 50px;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0.7;
            transition: opacity 0.3s;
            z-index: 1000;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            display: none;
        }
        
        .scrollToTop:hover {
            opacity: 1;
        }
        
        footer {
            background-color: var(--dark-bg);
            color: var(--light-text);
            text-align: center;
            padding: 1rem;
            border-radius: var(--border-radius);
            margin-top: 2rem;
        }
        
        /* Syntax highlighting for code */
        .keyword { color: #c678dd; }
        .function { color: #61afef; }
        .comment { color: #5c6370; font-style: italic; }
        .string { color: #98c379; }
        .number { color: #d19a66; }
        .operator { color: #56b6c2; }
        .class { color: #e6c07b; }
        
        /* Tree diagram styling */
        .tree-diagram {
            font-family: monospace;
            margin: 20px 0;
            white-space: pre;
            line-height: 1.4;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>DSAA2043 Spring 2025 Practice Questions</h1>
        </header>
        
        <section id="toc" class="toc">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#question1">Question 1: Master Theorem</a></li>
                <li><a href="#question2">Question 2: Stable Sorting</a></li>
                <li><a href="#question3">Question 3: Asymptotic Analysis</a></li>
                <li><a href="#question4">Question 4: Rotated Array Search</a></li>
                <li><a href="#question5">Question 5: Simplify Unix File Path</a></li>
                <li><a href="#question6">Question 6: Sliding Window Maximum</a></li>
                <li><a href="#question7">Question 7: Merge K Sorted Arrays</a></li>
                <li><a href="#question8">Question 8: Level Order Traversal</a></li>
                <li><a href="#question9">Question 9: Longest Root-to-Leaf Path</a></li>
            </ul>
        </section>
        
        <section id="question1" class="question-card">
            <div class="question-header">
                <h2>Practice Question 1 (Short Answer)</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Use the master theorem to find the asymptotic solution to the recurrence</p>
                <p>$T(n)=2T\left(\frac{n}{2}\right)+n^2$</p>
                <p>Determine the bound for $T(n)$.</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>Here, we have $a=2$, $b=2$, and $f(n)=n^2$. We compute the critical exponent:</p>
                    <p>$n^{\log_b a} = n^{\log_2 2} = n$</p>
                    <p>Since $f(n)$ grows faster than $n$ (i.e. $f(n)=\Omega(n^{1+\epsilon})$ for $\epsilon = 1$) and the regularity condition holds, by case 3 of the master theorem:</p>
                    <p>$T(n)=\Theta(n^2)$</p>
                </div>
            </div>
        </section>
        
        <section id="question2" class="question-card">
            <div class="question-header">
                <h2>Practice Question 2 (Short Answer)</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Give a concrete example to where the stableness of a sorting algorithm is desirable. Name a stable sorting algorithm.</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>E.g., sorting a collection of student records (already sorted by student ID) by their letter grades, while still making sure students in the same letter grade group is sorted by student ID.</p>
                    <p>An example of a stable sorting algorithm is merge sort.</p>
                </div>
            </div>
        </section>
        
        <section id="question3" class="question-card">
            <div class="question-header">
                <h2>Practice Question 3 (Short Answer)</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Prove that</p>
                <p>$S(n)=1^2+2^2+\cdots+n^2=\Theta(n^3)$</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>Either using the formula: $S(n)=\frac{n(n + 1)(2n + 1)}{6}$,</p>
                    <p>Or obviously $S(n) \leq \sum_{i=1}^{n} n^2 = O(n^3)$. To show the lower bound, we cut the sum into two halves.</p>
                    <p>$S(n) = \underbrace{\sum_{i=1}^{\frac{n}{2}} i^2}_{A} + \underbrace{\sum_{\frac{n}{2}}^{n} i^2}_{B}$</p>
                    <p>$\geq B = \Omega(n^3)$</p>
                </div>
            </div>
        </section>
        
        <section id="question4" class="question-card">
            <div class="question-header">
                <h2>Practice Question 4 (Coding)</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Given a rotated sorted array of distinct integers, implement an algorithm to find the minimum element in $O(\log n)$ time.</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>Use a modified binary search. Compare the middle element with the rightmost element to adjust the search boundaries until the minimum element is found.</p>
                    <pre><code><span class="keyword">class</span> <span class="class">Quest</span>:
    <span class="keyword">def</span> <span class="function">findMin</span>(<span class="keyword">self</span>, nums):
        low, high = <span class="number">0</span>, <span class="function">len</span>(nums) - <span class="number">1</span>
        <span class="keyword">while</span> low < high:
            mid = (low + high) // <span class="number">2</span>
            <span class="keyword">if</span> nums[mid] > nums[high]:
                low = mid + <span class="number">1</span>
            <span class="keyword">else</span>:
                high = mid
        <span class="keyword">return</span> nums[low]

<span class="comment"># Example test:</span>
solver = <span class="class">Quest</span>()
<span class="function">print</span>(solver.findMin([<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]))
<span class="comment"># Expected output: 0</span></code></pre>
                </div>
            </div>
        </section>
        
        <section id="question5" class="question-card">
            <div class="question-header">
                <h2>Practice Question 5: Simplify Unix File Path</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Given a string representing an absolute Unix file path (e.g., <code>/a/./b/../../c/</code>), simplify it. Use a stack to process the directories and produce the canonical path.</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>Push valid directory names onto the stack while processing components. Skip empty components or ".". When encountering "..", pop from the stack if not empty. Finally, join the stack components to form the simplified path.</p>
                    <pre><code><span class="keyword">def</span> <span class="function">simplifyPath</span>(path: <span class="class">str</span>) -> <span class="class">str</span>:
    stack = []
    <span class="comment"># Split the path by "/" and process each component</span>
    <span class="keyword">for</span> part <span class="keyword">in</span> path.split(<span class="string">"/"</span>):
        <span class="keyword">if</span> part == <span class="string">""</span> <span class="keyword">or</span> part == <span class="string">"."</span>:
            <span class="keyword">continue</span>
        <span class="keyword">elif</span> part == <span class="string">".."</span>:
            <span class="keyword">if</span> stack:
                stack.pop()
        <span class="keyword">else</span>:
            stack.append(part)
    <span class="keyword">return</span> <span class="string">"/"</span> + <span class="string">"/"</span>.join(stack)

<span class="comment"># Example test:</span>
<span class="function">print</span>(simplifyPath(<span class="string">"/a/./b/../../c/"</span>))
<span class="comment"># Expected output: "/c"</span>
<span class="function">print</span>(simplifyPath(<span class="string">"/../"</span>))
<span class="comment"># Expected output: "/"</span></code></pre>
                </div>
            </div>
        </section>
        
        <section id="question6" class="question-card">
            <div class="question-header">
                <h2>Practice Question 6: Sliding Window Maximum</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Given an array of $n$ integers and a window size $k$, compute the maximum value in each of the $n$ sliding window in $O(n)$ time.</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>Maintain a deque that stores indices of array elements in decreasing order. For each new element, remove indices that are out of the current window or whose values are less than the current value. The element at the front of the deque is the maximum for that window.</p>
                    <!DOCTYPE html>
<html>
<head>
<style>
pre {
    background: #282c34;
    color: #abb2bf;
    padding: 15px;
    border-radius: 5px;
    overflow-x: auto;
}

code {
    font-family: 'Consolas', 'Monaco', monospace;
}

.keyword {
    color: #c678dd;
}

.function {
    color: #61afef;  
}

.number {
    color: #d19a66;
}

.string {
    color: #98c379;
}

.comment {
    color: #7f848e;
    font-style: italic;
}

.class {
    color: #e5c07b;
}

@media (max-width: 480px) {
    pre {
        font-size: 14px;
        padding: 10px;
    }
}
</style>
</head>
<body>
<pre><code><span class="keyword">class</span> <span class="class">Node</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, value):
        <span class="keyword">self</span>.value = value
        <span class="keyword">self</span>.next = <span class="keyword">None</span>
        <span class="keyword">self</span>.prev = <span class="keyword">None</span>

<span class="comment"># Custom double-ended queue implementation using doubly linked list</span>
<span class="keyword">class</span> <span class="class">CustomDeque</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.head = <span class="keyword">None</span>  <span class="comment"># Head of the list (left end)</span>
        <span class="keyword">self</span>.tail = <span class="keyword">None</span>  <span class="comment"># Tail of the list (right end)</span>
        <span class="keyword">self</span>.size = <span class="number">0</span>
    
    <span class="keyword">def</span> <span class="function">append</span>(<span class="keyword">self</span>, item):
        new_node = <span class="class">Node</span>(item)
        <span class="keyword">if</span> <span class="keyword">self</span>.size == <span class="number">0</span>:
            <span class="keyword">self</span>.head = new_node
            <span class="keyword">self</span>.tail = new_node
        <span class="keyword">else</span>:
            <span class="keyword">self</span>.tail.next = new_node
            new_node.prev = <span class="keyword">self</span>.tail
            <span class="keyword">self</span>.tail = new_node
        <span class="keyword">self</span>.size += <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">pop</span>(<span class="keyword">self</span>):
        <span class="keyword">if</span> <span class="keyword">self</span>.size == <span class="number">0</span>:
            <span class="keyword">raise</span> <span class="class">IndexError</span>(<span class="string">"pop from an empty deque"</span>)
        
        value = <span class="keyword">self</span>.tail.value
        <span class="keyword">if</span> <span class="keyword">self</span>.size == <span class="number">1</span>:
            <span class="keyword">self</span>.head = <span class="keyword">None</span>
            <span class="keyword">self</span>.tail = <span class="keyword">None</span>
        <span class="keyword">else</span>:
            <span class="keyword">self</span>.tail = <span class="keyword">self</span>.tail.prev
            <span class="keyword">self</span>.tail.next = <span class="keyword">None</span>
        
        <span class="keyword">self</span>.size -= <span class="number">1</span>
        <span class="keyword">return</span> value

    <span class="keyword">def</span> <span class="function">popleft</span>(<span class="keyword">self</span>):
        <span class="keyword">if</span> <span class="keyword">self</span>.size == <span class="number">0</span>:
            <span class="keyword">raise</span> <span class="class">IndexError</span>(<span class="string">"pop from an empty deque"</span>)
        
        value = <span class="keyword">self</span>.head.value
        <span class="keyword">if</span> <span class="keyword">self</span>.size == <span class="number">1</span>:
            <span class="keyword">self</span>.head = <span class="keyword">None</span>
            <span class="keyword">self</span>.tail = <span class="keyword">None</span>
        <span class="keyword">else</span>:
            <span class="keyword">self</span>.head = <span class="keyword">self</span>.head.next
            <span class="keyword">self</span>.head.prev = <span class="keyword">None</span>
        
        <span class="keyword">self</span>.size -= <span class="number">1</span>
        <span class="keyword">return</span> value

    <span class="keyword">def</span> <span class="function">__len__</span>(<span class="keyword">self</span>):
        <span class="keyword">return</span> <span class="keyword">self</span>.size

    <span class="keyword">def</span> <span class="function">__bool__</span>(<span class="keyword">self</span>):
        <span class="keyword">return</span> <span class="keyword">self</span>.size > <span class="number">0</span>

    <span class="keyword">def</span> <span class="function">__getitem__</span>(<span class="keyword">self</span>, index):
        <span class="comment"># Handle negative indices</span>
        <span class="keyword">if</span> index < <span class="number">0</span>:
            index = <span class="keyword">self</span>.size + index
            
        <span class="keyword">if</span> index < <span class="number">0</span> <span class="keyword">or</span> index >= <span class="keyword">self</span>.size:
            <span class="keyword">raise</span> <span class="class">IndexError</span>(<span class="string">"Index out of range"</span>)
        
        <span class="keyword">if</span> index == <span class="number">0</span>:
            <span class="keyword">return</span> <span class="keyword">self</span>.head.value
        
        <span class="keyword">if</span> index == <span class="keyword">self</span>.size - <span class="number">1</span>:
            <span class="keyword">return</span> <span class="keyword">self</span>.tail.value
        
        <span class="comment"># Choose traversal direction based on whether the index is closer to head or tail</span>
        <span class="keyword">if</span> index <= <span class="keyword">self</span>.size // <span class="number">2</span>:
            current = <span class="keyword">self</span>.head
            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(index):
                current = current.next
        <span class="keyword">else</span>:
            current = <span class="keyword">self</span>.tail
            <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(<span class="keyword">self</span>.size - <span class="number">1</span> - index):
                current = current.prev
        
        <span class="keyword">return</span> current.value

<span class="keyword">def</span> <span class="function">slidingWindowMaximum</span>(nums, k):
    <span class="keyword">if</span> <span class="keyword">not</span> nums <span class="keyword">or</span> k <= <span class="number">0</span>:
        <span class="keyword">return</span> []
    dq = <span class="class">CustomDeque</span>()  <span class="comment"># Stores indices of potential max elements</span>
    result = []
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="function">range</span>(<span class="function">len</span>(nums)):
        <span class="comment"># Remove indices that are out of this window</span>
        <span class="keyword">while</span> dq <span class="keyword">and</span> dq[<span class="number">0</span>] < i - k + <span class="number">1</span>:
            dq.popleft()
        <span class="comment"># Remove indices whose corresponding values are less than nums[i]</span>
        <span class="keyword">while</span> dq <span class="keyword">and</span> nums[dq[-<span class="number">1</span>]] < nums[i]:
            dq.pop()
        dq.append(i)
        <span class="comment"># Append the maximum for this window when the first full window is reached</span>
        <span class="keyword">if</span> i >= k - <span class="number">1</span>:
            result.append(nums[dq[<span class="number">0</span>]])
    <span class="keyword">return</span> result

<span class="comment"># Example test:</span>
<span class="function">print</span>(slidingWindowMaximum([<span class="number">1</span>,<span class="number">3</span>,-<span class="number">1</span>,-<span class="number">3</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>], <span class="number">3</span>))  <span class="comment"># Expected output: [3,3,5,5,6,7]</span></code></pre>
</body>
</html>
                </div>
            </div>
        </section>
        
        <section id="question7" class="question-card">
            <div class="question-header">
                <h2>Practice Question 7: Merge K Sorted Arrays</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Given $k$ sorted integer arrays, merge them into one sorted array. Use a min-priority queue (heap) to efficiently perform the merge.</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>Use a min-heap where each entry is a tuple containing the element value, its originating array index, and the element's index within that array. Extract the smallest element from the heap and push the next element from the same array if available.</p>
                    <!DOCTYPE html>
<html>
<head>
<style>
pre {
    background: #282c34;
    color: #abb2bf;
    padding: 15px;
    border-radius: 5px;
    overflow-x: auto;
}

code {
    font-family: 'Consolas', 'Monaco', monospace;
}

.keyword {
    color: #c678dd;
}

.function {
    color: #61afef;  
}

.number {
    color: #d19a66;
}

.string {
    color: #98c379;
}

.comment {
    color: #7f848e;
    font-style: italic;
}

.class {
    color: #e5c07b;
}

@media (max-width: 480px) {
    pre {
        font-size: 14px;
        padding: 10px;
    }
}
</style>
</head>
<body>
<pre><code><span class="keyword">class</span> <span class="class">Heapq</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.heap = []
    
    <span class="keyword">def</span> <span class="function">heappush</span>(<span class="keyword">self</span>, heap, item):
        <span class="string">"""Push item onto heap, maintaining the heap invariant."""</span>
        heap.append(item)
        <span class="keyword">self</span>._siftup(heap, <span class="function">len</span>(heap) - <span class="number">1</span>)
    
    <span class="keyword">def</span> <span class="function">heappop</span>(<span class="keyword">self</span>, heap):
        <span class="string">"""Pop and return the smallest item from the heap."""</span>
        <span class="keyword">if</span> <span class="keyword">not</span> heap:
            <span class="keyword">raise</span> <span class="class">IndexError</span>(<span class="string">"pop from empty heap"</span>)
        last_item = heap.pop()
        <span class="keyword">if</span> heap:
            return_item = heap[<span class="number">0</span>]
            heap[<span class="number">0</span>] = last_item
            <span class="keyword">self</span>._siftdown(heap, <span class="number">0</span>)
            <span class="keyword">return</span> return_item
        <span class="keyword">return</span> last_item
    
    <span class="keyword">def</span> <span class="function">_siftup</span>(<span class="keyword">self</span>, heap, index):
        <span class="string">"""Move the element at index up to maintain heap property."""</span>
        item = heap[index]
        <span class="keyword">while</span> index > <span class="number">0</span>:
            parent = (index - <span class="number">1</span>) // <span class="number">2</span>
            <span class="keyword">if</span> heap[parent] <= item:
                <span class="keyword">break</span>
            heap[index] = heap[parent]
            index = parent
        heap[index] = item
    
    <span class="keyword">def</span> <span class="function">_siftdown</span>(<span class="keyword">self</span>, heap, index):
        <span class="string">"""Move the element at index down to maintain heap property."""</span>
        item = heap[index]
        n = <span class="function">len</span>(heap)
        <span class="keyword">while</span> <span class="keyword">True</span>:
            left = <span class="number">2</span> * index + <span class="number">1</span>
            right = <span class="number">2</span> * index + <span class="number">2</span>
            smallest = index
            <span class="keyword">if</span> left < n <span class="keyword">and</span> heap[left] < heap[smallest]:
                smallest = left
            <span class="keyword">if</span> right < n <span class="keyword">and</span> heap[right] < heap[smallest]:
                smallest = right
            <span class="keyword">if</span> smallest == index:
                <span class="keyword">break</span>
            heap[index] = heap[smallest]
            index = smallest
        heap[index] = item

<span class="keyword">def</span> <span class="function">mergeKSortedArrays</span>(arrays):
    heapq = <span class="class">Heapq</span>()
    min_heap = []
    result = []

    <span class="comment"># Initialize heap with the first element of each array along with array and element indices</span>
    <span class="keyword">for</span> i, arr <span class="keyword">in</span> <span class="function">enumerate</span>(arrays):
        <span class="keyword">if</span> arr:  <span class="comment"># Ensure the array is not empty</span>
            heapq.heappush(min_heap, (arr[<span class="number">0</span>], i, <span class="number">0</span>))
    
    <span class="keyword">while</span> min_heap:
        val, arr_idx, elem_idx = heapq.heappop(min_heap)
        result.append(val)
        <span class="keyword">if</span> elem_idx + <span class="number">1</span> < <span class="function">len</span>(arrays[arr_idx]):
            next_val = arrays[arr_idx][elem_idx + <span class="number">1</span>]
            heapq.heappush(min_heap, (next_val, arr_idx, elem_idx + <span class="number">1</span>))
    
    <span class="keyword">return</span> result

<span class="comment"># Example test:</span>
arrays = [
    [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],
    [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],
    [<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>]
]
<span class="function">print</span>(mergeKSortedArrays(arrays))  <span class="comment"># Expected output: [1,2,3,4,5,6,7,8,9]</span></code></pre>
</body>
</html>
                </div>
            </div>
        </section>
        
        <section id="question8" class="question-card">
            <div class="question-header">
                <h2>Practice Question 8: Level Order Traversal in a Binary Tree (Using Queue)</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Given a binary tree, perform a level order traversal (breadth-first search) and return the list of values at each level. Use a queue to facilitate the traversal.</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>Use a queue to process nodes level by level. For each level, dequeue all nodes in the current level and enqueue their children, accumulating the node values in a list.</p>
                    <!DOCTYPE html>
<html>
<head>
<style>
pre {
    background: #282c34;
    color: #abb2bf;
    padding: 15px;
    border-radius: 5px;
    overflow-x: auto;
}

code {
    font-family: 'Consolas', 'Monaco', monospace;
}

.keyword {
    color: #c678dd;
}

.function {
    color: #61afef;  
}

.number {
    color: #d19a66;
}

.string {
    color: #98c379;
}

.comment {
    color: #7f848e;
    font-style: italic;
}

.class {
    color: #e5c07b;
}

@media (max-width: 480px) {
    pre {
        font-size: 14px;
        padding: 10px;
    }
}
</style>
</head>
<body>
<pre><code><span class="comment"># Custom Node class for linked list implementation</span>
<span class="keyword">class</span> <span class="class">Node</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, value):
        <span class="keyword">self</span>.value = value
        <span class="keyword">self</span>.next = <span class="keyword">None</span>

<span class="comment"># Custom queue implementation using singly linked list</span>
<span class="keyword">class</span> <span class="class">CustomQueue</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>):
        <span class="keyword">self</span>.head = <span class="keyword">None</span>  <span class="comment"># Head of queue (dequeue from here)</span>
        <span class="keyword">self</span>.tail = <span class="keyword">None</span>  <span class="comment"># Tail of queue (enqueue here)</span>
        <span class="keyword">self</span>.size = <span class="number">0</span>
    
    <span class="keyword">def</span> <span class="function">append</span>(<span class="keyword">self</span>, item):
        new_node = <span class="class">Node</span>(item)
        <span class="keyword">if</span> <span class="keyword">self</span>.size == <span class="number">0</span>:
            <span class="keyword">self</span>.head = new_node
            <span class="keyword">self</span>.tail = new_node
        <span class="keyword">else</span>:
            <span class="keyword">self</span>.tail.next = new_node
            <span class="keyword">self</span>.tail = new_node
        <span class="keyword">self</span>.size += <span class="number">1</span>
    
    <span class="keyword">def</span> <span class="function">popleft</span>(<span class="keyword">self</span>):
        <span class="keyword">if</span> <span class="keyword">self</span>.size == <span class="number">0</span>:
            <span class="keyword">raise</span> <span class="class">IndexError</span>(<span class="string">"pop from an empty queue"</span>)
        
        value = <span class="keyword">self</span>.head.value
        <span class="keyword">self</span>.head = <span class="keyword">self</span>.head.next
        
        <span class="keyword">if</span> <span class="keyword">self</span>.head <span class="keyword">is</span> <span class="keyword">None</span>:
            <span class="keyword">self</span>.tail = <span class="keyword">None</span>
        
        <span class="keyword">self</span>.size -= <span class="number">1</span>
        <span class="keyword">return</span> value
    
    <span class="keyword">def</span> <span class="function">__len__</span>(<span class="keyword">self</span>):
        <span class="keyword">return</span> <span class="keyword">self</span>.size
    
    <span class="keyword">def</span> <span class="function">__bool__</span>(<span class="keyword">self</span>):
        <span class="keyword">return</span> <span class="keyword">self</span>.size > <span class="number">0</span>

<span class="keyword">class</span> <span class="class">TreeNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, val=<span class="number">0</span>, left=<span class="keyword">None</span>, right=<span class="keyword">None</span>):
        <span class="keyword">self</span>.val = val
        <span class="keyword">self</span>.left = left
        <span class="keyword">self</span>.right = right

<span class="keyword">def</span> <span class="function">levelOrder</span>(root: <span class="class">TreeNode</span>) -> list:
    <span class="keyword">if</span> <span class="keyword">not</span> root:
        <span class="keyword">return</span> []
    result = []
    queue = <span class="class">CustomQueue</span>()
    queue.append(root)
    <span class="keyword">while</span> queue:
        level_size = <span class="function">len</span>(queue)
        level_vals = []
        <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="function">range</span>(level_size):
            node = queue.popleft()
            level_vals.append(node.val)
            <span class="keyword">if</span> node.left:
                queue.append(node.left)
            <span class="keyword">if</span> node.right:
                queue.append(node.right)
        result.append(level_vals)
    <span class="keyword">return</span> result

<span class="comment"># Example test:</span>
root = <span class="class">TreeNode</span>(<span class="number">1</span>)
root.left = <span class="class">TreeNode</span>(<span class="number">2</span>)
root.right = <span class="class">TreeNode</span>(<span class="number">3</span>)
root.left.left = <span class="class">TreeNode</span>(<span class="number">4</span>)
root.left.right = <span class="class">TreeNode</span>(<span class="number">5</span>)
<span class="function">print</span>(levelOrder(root))  <span class="comment"># Expected output: [[1], [2, 3], [4, 5]]</span></code></pre>
</body>
</html>
                </div>
            </div>
        </section>
        
        <section id="question9" class="question-card">
            <div class="question-header">
                <h2>Practice Question 9: Find the Longest Root-to-Leaf Path in a Binary Tree</h2>
                <a href="#toc" class="back-to-toc">Back to TOC</a>
            </div>
            <div class="question-content">
                <p><strong>Question:</strong></p>
                <p>Write a recursive function <code>longestRootToLeafPath(root)</code> that returns the longest path from the root to any leaf in a binary tree. The path should be returned as a list of node values. If multiple paths have the same length, you can return any one of them.</p>
                <p>For instance, consider the following tree:</p>
                <div class="tree-diagram">
    1
   / \
  2   3
 /     \
4       5
         \
          6
                </div>
                <p>The function could return <code>[1, 3, 5, 6]</code> as the longest root-to-leaf path.</p>
            </div>
            <div class="solution-container">
                <button class="show-solution-btn">Show Solution</button>
                <div class="solution-content">
                    <p>We can solve this problem recursively by defining the following approach:</p>
                    <ul>
                        <li><strong>Base Case:</strong> If the node is <code>None</code>, return an empty list (i.e., no path).</li>
                        <li><strong>Leaf Node:</strong> If the node has no children, return a list containing only the node's value.</li>
                        <li><strong>Recursive Case:</strong> Compute the longest path from the left subtree and from the right subtree. Compare their lengths, and select the longer one. Then prepend the current node's value to that path and return the result.</li>
                    </ul>
                    <p>Below is the corresponding Python implementation:</p>
                    <pre><code><span class="keyword">class</span> <span class="class">TreeNode</span>:
    <span class="keyword">def</span> <span class="function">__init__</span>(<span class="keyword">self</span>, val=<span class="number">0</span>, left=<span class="keyword">None</span>, right=<span class="keyword">None</span>):
        <span class="keyword">self</span>.val = val
        <span class="keyword">self</span>.left = left
        <span class="keyword">self</span>.right = right

<span class="keyword">def</span> <span class="function">longestRootToLeafPath</span>(root: TreeNode) -> <span class="class">list</span>:
    <span class="comment"># Base case: if the node is None, return an empty path.</span>
    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="keyword">None</span>:
        <span class="keyword">return</span> []
    
    <span class="comment"># Base case: if the node is a leaf, return a list with its value.</span>
    <span class="keyword">if</span> root.left <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">and</span> root.right <span class="keyword">is</span> <span class="keyword">None</span>:
        <span class="keyword">return</span> [root.val]
    
    <span class="comment"># Recursively get longest paths from left and right subtrees</span>
    left_path = <span class="function">longestRootToLeafPath</span>(root.left)
    right_path = <span class="function">longestRootToLeafPath</span>(root.right)
    
    <span class="comment"># Select the longer of two paths</span>
    <span class="keyword">if</span> <span class="function">len</span>(left_path) > <span class="function">len</span>(right_path):
        longer_path = left_path
    <span class="keyword">else</span>:
        longer_path = right_path
    
    <span class="comment"># Include the current node's value at the start of the longer path and return.</span>
    <span class="keyword">return</span> [root.val] + longer_path

<span class="comment"># Example test:</span>
<span class="comment"># Constructing the binary tree:</span>
<span class="comment">#         1</span>
<span class="comment">#        / \</span>
<span class="comment">#       2   3</span>
<span class="comment">#      /     \</span>
<span class="comment">#     4       5</span>
<span class="comment">#                \</span>
<span class="comment">#                 6</span>
root = <span class="class">TreeNode</span>(<span class="number">1</span>)
root.left = <span class="class">TreeNode</span>(<span class="number">2</span>, <span class="class">TreeNode</span>(<span class="number">4</span>))
root.right = <span class="class">TreeNode</span>(<span class="number">3</span>, <span class="keyword">None</span>, <span class="class">TreeNode</span>(<span class="number">5</span>, <span class="keyword">None</span>, <span class="class">TreeNode</span>(<span class="number">6</span>)))

path = <span class="function">longestRootToLeafPath</span>(root)
<span class="function">print</span>(<span class="string">"Longest root-to-leaf path:"</span>, path)
<span class="comment"># Expected output: Longest root-to-leaf path: [1, 3, 5, 6]</span></code></pre>
                </div>
            </div>
        </section>
        
        <div class="scrollToTop">â†‘</div>
        
        <footer>
            <p>DSAA2043 Spring 2025 - Data Structures and Algorithms</p>
        </footer>
    </div>
    
    <script>
        // Solution toggle logic
        document.querySelectorAll('.show-solution-btn').forEach(button => {
            button.addEventListener('click', function() {
                const solutionContent = this.nextElementSibling;
                if (solutionContent.style.display === 'block') {
                    solutionContent.style.display = 'none';
                    this.textContent = 'Show Solution';
                } else {
                    solutionContent.style.display = 'block';
                    this.textContent = 'Hide Solution';
                }
            });
        });
        
        // Scroll to top button logic
        const scrollToTopBtn = document.querySelector('.scrollToTop');
        
        window.onscroll = function() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                scrollToTopBtn.style.display = 'block';
            } else {
                scrollToTopBtn.style.display = 'none';
            }
        };
        
        scrollToTopBtn.addEventListener('click', function() {
            document.body.scrollTop = 0; // For Safari
            document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
        });
    </script>
</body>
</html>